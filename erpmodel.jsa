'use strict';



/**
 * Module dependencies.
 */
var mongoose = require('mongoose'),
  Schema = mongoose.Schema,
 // crypto = require('crypto'),
 // _ = require('lodash'),
  Q = require('q');

 
mongoose.connect('mongodb://localhost/erptest');
console.log('hello');


//Need administrator to config these information: InventoryUnit, InventorySchema, QualitySchema, CoalMine


//ChemicalAttrObjectList
//ChemicalAttrObject is {
// //Mar Mad Aad Ad  Vad Vdaf  FCad  St,ad Qb,ad Qgr,d Qnet,v,ar Qnet,v,ar
//   Mar: Number,
//   Mad: Number,
//   Aad: Number,
//   Ad: Number,
//   Vad: Number,
//   Vdaf: Number,
//   FCad: Number,
//   St_ad: Number,
//   Qb_ad: Number,
//   Qgr_d: Number,
//   Qnet_v_ar: Number,
//   Qnet_v_ar_cal: Number,
//}

var QualitySchema = new Schema({
  contents: [String],
  //ChemicalAttrObjectList  NOX, 
  //[{name: NOX, unit:'kg',}]
});

var Quality = mongoose.model('Quality', QualitySchema);

/**
 * QualitySchema Statics
 */
QualitySchema.statics = {
  addQuality: function(newQuality, cb) {
    var deferred = Q.defer();

    console.log('typeof this:', (typeof this));
    var p = this.findOne({}).exec();
    p.addCallback(function(quality) {
      quality = quality ? quality : new Quality({
        contents: []
      });

      if (quality.contents.indexOf(newQuality) < 0) {
        quality.contents.push(newQuality);
      }

      quality.save(function(err, savedQuality, numberAffected) {
        console.log(err, savedQuality, numberAffected);
        if (err) {
          deferred.reject(err);
        } else {
          deferred.resolve(savedQuality.contents);
        }
      });
    });

    p.addErrback(function(err) {
      deferred.reject(err);
    });

    return deferred.promise.nodeify(cb);
  },

  getQuality: function(cb) {
    var deferred = Q.defer();

    var p = this.findOne({}).exec();
    p.addCallback(function(quality) {
      var contents = quality ? quality.contents : [];
      deferred.resolve(contents); 
    });

    p.addErrback(function(err) {
      deferred.reject(err);
    });

    return deferred.promise.nodeify(cb);
  },

  validate: function(quality, cb) {
    Quality.getQuality(function(err, contents) {
      //console.log('QualitySchema.validate:', err, contents);
      if (err) {
        cb(false);
        return; 
      }
      if (contents.indexOf(quality) < 0) {
        cb(false);
        return;
      }

      cb(true);
    });
  }
};


var InventoryUnitSchema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true,
    unique: true,
  },
  // quality: {
  //   type: String,
  //   required: true,
  //   trim: true
  // },
  weight: {
    type: Number,
    required: true
  },

  //Add ChemicalAttrObjectList

  // power: {
  //   type: Number,
  //   required: true
  // },
  // nitrogen: {
  //   type: Number,
  //   required: true
  // },

});




var InventorySchema = new Schema({

  inventory: [InventoryUnitSchema],

  created: {
    type: Date,
    default: Date.now
  },

  datasource: {
    type: String,
    required: true,
    default: 'manual',
    enum: ['manual', 'system'],
  },
   
});

var CoalMineSchema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true,
    unique: true,
  },
  quality: {
    type: String,
    required: true,
    trim: true,
    validate: [Quality.validate, 'invalid quality value'],
  },

  created: {
    type: Date,
    default: Date.now
  },

  modified: {
    type: Date,
    default: Date.now
  },
});

CoalMineSchema.pre('save', function(next) {
  if (!this.isNew) {
    console.log('update modified date');
    this.modified = Date.now;
  }

  next();
});


//Got from SystemA
var CoalBuyTransactionSchema = new Schema({
  //Following data is got from SystemA
  date: {
    type: Date,
    default: Date.now
  },
  coalminename: {
    type: String,
    required: true,
    trim: true
  },

  coalmine: {
    type: Schema.ObjectId,
    ref: 'CoalMine'
  },

  inventoryUnitName: {
    type: String,
    required: true,
    trim: true
  },

  inventoryUnitId: {
    type: InventoryUnit,
    required: true,
    trim: true
  },

  weightchecked: {
    //Boolean
  },

  weight: {
    type: Number,
    required: true
  },

   //chemical check
  // ChemicalAttrObjectList
  // chemicalchecked: {
  //   //Boolean
  // },


  //From now on, following data is caculated by server
  created: {
    type: Date,
    default: Date.now
  },
  
});

// CoalBuyTransactionSchema.pre('save', function(next) {
//   if (!this.isNew) {
//     console.log('update modified date');
//     this.modified = Date.now;
//   };

//   next();
// });

var CoalProductionPlanSchema = new Schema({

  useplan: [InventoryUnitSchema],
  date: {
    type: Date,
    default: Date.now
  },

  created: {
    type: Date,
    default: Date.now
  },

  modified: {
    type: Date,
    default: Date.now
  },

  // manualhistory: [ManualMofifyRecordSchema],
});

// var CoalConsuptionDataSISSchema = new Schema({
//   date: {
//     type: Date,
//     default: Date.now
//   },
//   accuweight: {
//     type: Number,
//     required: true
//   },
// });

// var MineCostSchema = new Schema({
   
  

//   workschedule: {
//     type: String,
//     required: true,
//     trim: true,
//     enum: ['morning', 'noon', 'earlynight', 'latenight'],
//   },

// });

var CoalDailyConsumptionSchema = new Schema({
  //Following data is got from SystemB
  date: {
    type: Date,
    default: Date.now
  },
  
  //sisdata: [CoalConsuptionDataSISSchema],
   

  inventoryUnitName: {
    type: String,
    required: true,
    trim: true
  },

  inventoryUnitId: {
    type: InventoryUnit,
    required: true,
    trim: true
  },

  weight: {
    type: Number,
    required: true
  },
  

  created: {
    type: Date,
    default: Date.now
  },

  modified: {
    type: Date,
    default: Date.now
  },
});


//var CoalMine = mongoose.model('CoalMine', CoalMineSchema);
mongoose.model('Inventory', InventorySchema);
var CoalBuyTransaction = mongoose.model('CoalBuyTransaction', CoalBuyTransactionSchema);
mongoose.model('CoalProductionPlan', CoalProductionPlanSchema);
mongoose.model('CoalDailyConsumption', CoalDailyConsumptionSchema);
 
// Quality.addQuality('优秀3').then(function(contents) {
//   console.log('contents: ', contents);
// }, function(err) {
//   console.error('addQuality error', err);
// });

// Quality.getQuality(function(err, data) {
//   console.log(err, data);
// });

// var coalmine = new CoalMine({name: 'aa', quality: '优秀'});
// coalmine.save(function(err, value) {
//   console.log('coalmine save result:', err, value);

// });

var tran = new CoalBuyTransaction({
  coalminename: '晓兵',
  weight: 34.4
});
tran.save();




//mongoose.disconnect();

// QualitySchema， InventoryUnit, InventorySchema, , CoalMine //Initial configuration

// CoalDailyConsumptionSchema  //Got from sis 
// CoalProductionPlanSchema    //Got from operator
// CoalBuyTransactionSchema    //Got from SystemA

// Question:
// 1. how to calculate coal consumpltion
// 2. which table can be modified


// 1. 入煤数据修改要记录修改历史和原因  生产计划现在只记录修改历史
// 2. 煤耗记录修改历史和原因，工人只能输入一次，jt可以修改多次
// 3. 库存信息只允许初始化和重置，从重置之日起，其后每天的库存都是根据来煤和煤耗实时计算得出。
// 4. 关于煤管班，应该是有个类似【审核】的功能流程
//     煤管班可以输入，景涛再确认
//     确认前的数据只记录，不计算
//     另外就是，在景涛确认数据时，有个时间先后顺序，如果有多个记录等待确认，比如昨天来了一批煤，今天来了一批煤，只确认今天的来煤的话，给出提示应先确认昨天的来煤   

//CoalBuyTransactionSchema: record modify    


//来煤选择流程
//1. 先输入来煤数量，化验员化验审核通过，jt才能能审核通过，才能参与库存计算
//2. 系统初始化矿源时候输入各个矿源的煤直信息，当煤管工输入来煤数量，即使化验员没有输入媒质信息， jt也能审核通过， 并且参与库存媒质计算。计算方法，利用
//   初始估算的煤直信息。化验结果审核通过后，再次修正计算

//库存表每次实时更新（来煤或者用煤审核通过），同时需要记录jt所有的修改
//查看日志: InventoryUnit修改的前后值

//所有的修改都需要记录操作员

//xulong更近报表统计


//@xulong：
// 1. 来煤录入： 除了录入重量外，还要录入媒质（nxo，  so2）之类； 当jt审核之后，利用录入媒质计算库存重量和媒质
                一旦化验员化验并且审核通过之后，利用更新的媒质来计算库存重量和媒质，但是需要留底。需要留底查询，@张创设计
// 2. 



  //need to cache binlocation weight data in this stage (good receipt check pass)


